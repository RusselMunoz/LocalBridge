<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LocalBridge Client</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0d0d0d;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-family: system-ui, sans-serif;
      color: #eee;
    }
    #status {
      margin-bottom: 12px;
      font-size: 13px;
      letter-spacing: .5px;
      opacity: .7;
    }
    #screen {
      width: 100%;
      max-width: 1280px;
      aspect-ratio: 16/9;
      background: #111;
      border: 1px solid #222;
      border-radius: 6px;
      cursor: none; /* we handle the cursor via input events */
      display: block;
    }
    #connect-btn {
      margin-top: 16px;
      padding: 10px 28px;
      background: #2563eb;
      border: none;
      border-radius: 6px;
      color: #fff;
      font-size: 15px;
      cursor: pointer;
      transition: background .2s;
    }
    #connect-btn:hover { background: #1d4ed8; }
    #connect-btn:disabled { background: #444; cursor: default; }
  </style>
</head>
<body>
  <div id="status">Not connected</div>
  <video id="screen" autoplay playsinline muted></video>
  <button id="connect-btn">Connect</button>

<script>
'use strict';

/**
 * This frontend uses the built-in browser WebRTC API to connect to our Rust server.
 */

const video    = document.getElementById('screen');
const statusEl = document.getElementById('status');
const btn      = document.getElementById('connect-btn');

// â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 'window.location.origin' is the URL of the server that served this page.
const HOST = window.location.origin;

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let pc = null; // The PeerConnection object (the heart of WebRTC)
let dc = null; // The DataChannel (used for sending mouse/keyboard events)

// â”€â”€ Connect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
btn.addEventListener('click', connect);

async function connect() {
  btn.disabled = true;
  setStatus('Connectingâ€¦');

  // 1. Create a new WebRTC PeerConnection.
  // We use Google's STUN server to help figure out how to connect through firewalls.
  pc = new RTCPeerConnection({
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  });

  // 2. This event triggers when the server starts sending video.
  pc.ontrack = e => {
    if (e.track.kind === 'video') {
      // Set the video element's source to the incoming stream.
      video.srcObject = e.streams[0];
      setStatus('ðŸŸ¢ Connected');
    }
  };

  // Monitor the connection state.
  pc.oniceconnectionstatechange = () => {
    if (['disconnected','failed','closed'].includes(pc.iceConnectionState)) {
      setStatus('ðŸ”´ Disconnected â€” refresh to reconnect');
      btn.disabled = false;
    }
  };

  // 3. Create a DataChannel for sending input events (keyboard/mouse).
  // 'ordered: false' and 'maxRetransmits: 0' makes it faster (like UDP).
  dc = pc.createDataChannel('input', { ordered: false, maxRetransmits: 0 });

  // 4. Tell the PeerConnection that we want to receive video.
  pc.addTransceiver('video', { direction: 'recvonly' });

  // 5. Generate a "WebRTC Offer" (a piece of text describing our capabilities).
  const offer  = await pc.createOffer();
  await pc.setLocalDescription(offer);

  // 6. Send our offer to the Rust server via a standard POST request.
  const res = await fetch(`${HOST}/offer`, {
    method:  'POST',
    headers: { 'Content-Type': 'application/json' },
    body:    JSON.stringify({ sdp: offer.sdp, type: offer.type }),
  });

  const answer = await res.json();
  if (answer.error) { setStatus('Error: ' + answer.error); return; }

  // 7. Receive the "Answer" from the server and tell WebRTC about it.
  // Now the two peers can start trying to talk directly to each other.
  await pc.setRemoteDescription(new RTCSessionDescription(answer));
  setStatus('ðŸŸ¡ Waiting for streamâ€¦');
}

// â”€â”€ Input forwarding â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Helper to send a JSON object over the WebRTC DataChannel.
 */
function send(obj) {
  if (dc && dc.readyState === 'open') {
    dc.send(JSON.stringify(obj));
  }
}

/**
 * Normalizes mouse coordinates from 0.0 to 1.0 based on the video element size.
 * This ensures the mouse position is correct even if the video is resized.
 */
function rel(e) {
  const r = video.getBoundingClientRect();
  return {
    x: (e.clientX - r.left) / r.width,
    y: (e.clientY - r.top)  / r.height,
  };
}

// Listen for mouse and keyboard events and forward them to the server.

video.addEventListener('mousemove', e => {
  const { x, y } = rel(e);
  send({ type: 'mouse_move', x, y });
});

video.addEventListener('mousedown', e => {
  const { x, y } = rel(e);
  send({ type: 'mouse_down', x, y, button: e.button });
});

video.addEventListener('mouseup', e => {
  const { x, y } = rel(e);
  send({ type: 'mouse_up', x, y, button: e.button });
});

video.addEventListener('wheel', e => {
  send({ type: 'mouse_scroll', dx: e.deltaX, dy: e.deltaY });
}, { passive: true });

document.addEventListener('keydown', e => {
  send({ type: 'key_down', code: e.code });
});

document.addEventListener('keyup', e => {
  send({ type: 'key_up', code: e.code });
});

// Prevent browser from hijacking right-click on the video.
video.addEventListener('contextmenu', e => e.preventDefault());

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setStatus(msg) { statusEl.textContent = msg; }
</script>
</body>
</html>